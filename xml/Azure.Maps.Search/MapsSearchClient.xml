<Type Name="MapsSearchClient" FullName="Azure.Maps.Search.MapsSearchClient">
  <TypeSignature Language="C#" Value="public class MapsSearchClient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MapsSearchClient extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Azure.Maps.Search.MapsSearchClient" />
  <TypeSignature Language="VB.NET" Value="Public Class MapsSearchClient" />
  <TypeSignature Language="F#" Value="type MapsSearchClient = class" />
  <AssemblyInfo>
    <AssemblyName>Azure.Maps.Search</AssemblyName>
    <AssemblyVersion>1.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary> The Search service client. </summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MapsSearchClient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary> Initializes a new instance of MapsSearchClient. </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MapsSearchClient (Azure.AzureKeyCredential credential);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Azure.AzureKeyCredential credential) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.#ctor(Azure.AzureKeyCredential)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (credential As AzureKeyCredential)" />
      <MemberSignature Language="F#" Value="new Azure.Maps.Search.MapsSearchClient : Azure.AzureKeyCredential -&gt; Azure.Maps.Search.MapsSearchClient" Usage="new Azure.Maps.Search.MapsSearchClient credential" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="credential" Type="Azure.AzureKeyCredential" />
      </Parameters>
      <Docs>
        <param name="credential"> Shared key credential used to authenticate to an Azure Maps Search Service. </param>
        <summary> Initializes a new instance of MapsSearchClient. </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MapsSearchClient (Azure.AzureKeyCredential credential, Azure.Maps.Search.MapsSearchClientOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Azure.AzureKeyCredential credential, class Azure.Maps.Search.MapsSearchClientOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.#ctor(Azure.AzureKeyCredential,Azure.Maps.Search.MapsSearchClientOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (credential As AzureKeyCredential, options As MapsSearchClientOptions)" />
      <MemberSignature Language="F#" Value="new Azure.Maps.Search.MapsSearchClient : Azure.AzureKeyCredential * Azure.Maps.Search.MapsSearchClientOptions -&gt; Azure.Maps.Search.MapsSearchClient" Usage="new Azure.Maps.Search.MapsSearchClient (credential, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="credential" Type="Azure.AzureKeyCredential" />
        <Parameter Name="options" Type="Azure.Maps.Search.MapsSearchClientOptions" />
      </Parameters>
      <Docs>
        <param name="credential"> Shared key credential used to authenticate to an Azure Maps Search Service. </param>
        <param name="options"> The options for configuring the client. </param>
        <summary> Initializes a new instance of MapsSearchClient. </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MapsSearchClient (Azure.Core.TokenCredential credential, string clientId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Azure.Core.TokenCredential credential, string clientId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.#ctor(Azure.Core.TokenCredential,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (credential As TokenCredential, clientId As String)" />
      <MemberSignature Language="F#" Value="new Azure.Maps.Search.MapsSearchClient : Azure.Core.TokenCredential * string -&gt; Azure.Maps.Search.MapsSearchClient" Usage="new Azure.Maps.Search.MapsSearchClient (credential, clientId)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="credential" Type="Azure.Core.TokenCredential" />
        <Parameter Name="clientId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="credential"> A credential used to authenticate to an Azure Maps Search Service. </param>
        <param name="clientId"> Specifies which account is intended for usage in conjunction with the Azure AD security model.  It represents a unique ID for the Azure Maps account and can be retrieved from the Azure Maps management  plane Account API. To use Azure AD security in Azure Maps see the following <see href="https://aka.ms/amauthdetails">articles</see> for guidance. </param>
        <summary> Initializes a new instance of MapsSearchClient. </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MapsSearchClient (Azure.Core.TokenCredential credential, string clientId, Azure.Maps.Search.MapsSearchClientOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Azure.Core.TokenCredential credential, string clientId, class Azure.Maps.Search.MapsSearchClientOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.#ctor(Azure.Core.TokenCredential,System.String,Azure.Maps.Search.MapsSearchClientOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (credential As TokenCredential, clientId As String, options As MapsSearchClientOptions)" />
      <MemberSignature Language="F#" Value="new Azure.Maps.Search.MapsSearchClient : Azure.Core.TokenCredential * string * Azure.Maps.Search.MapsSearchClientOptions -&gt; Azure.Maps.Search.MapsSearchClient" Usage="new Azure.Maps.Search.MapsSearchClient (credential, clientId, options)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="credential" Type="Azure.Core.TokenCredential" />
        <Parameter Name="clientId" Type="System.String" />
        <Parameter Name="options" Type="Azure.Maps.Search.MapsSearchClientOptions" />
      </Parameters>
      <Docs>
        <param name="credential"> A credential used to authenticate to an Azure Maps Search Service. </param>
        <param name="clientId"> Specifies which account is intended for usage in conjunction with the Azure AD security model.  It represents a unique ID for the Azure Maps account and can be retrieved from the Azure Maps management  plane Account API. To use Azure AD security in Azure Maps see the following <see href="https://aka.ms/amauthdetails">articles</see> for guidance. </param>
        <param name="options"> The options for configuring the client. </param>
        <summary> Initializes a new instance of MapsSearchClient. </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FuzzyBatchSearch">
      <MemberSignature Language="C#" Value="public virtual Azure.Maps.Search.FuzzySearchBatchOperation FuzzyBatchSearch (Azure.WaitUntil waitUntil, System.Collections.Generic.IEnumerable&lt;Azure.Maps.Search.Models.FuzzySearchQuery&gt; queries, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Maps.Search.FuzzySearchBatchOperation FuzzyBatchSearch(valuetype Azure.WaitUntil waitUntil, class System.Collections.Generic.IEnumerable`1&lt;class Azure.Maps.Search.Models.FuzzySearchQuery&gt; queries, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.FuzzyBatchSearch(Azure.WaitUntil,System.Collections.Generic.IEnumerable{Azure.Maps.Search.Models.FuzzySearchQuery},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FuzzyBatchSearch (waitUntil As WaitUntil, queries As IEnumerable(Of FuzzySearchQuery), Optional cancellationToken As CancellationToken = Nothing) As FuzzySearchBatchOperation" />
      <MemberSignature Language="F#" Value="abstract member FuzzyBatchSearch : Azure.WaitUntil * seq&lt;Azure.Maps.Search.Models.FuzzySearchQuery&gt; * System.Threading.CancellationToken -&gt; Azure.Maps.Search.FuzzySearchBatchOperation&#xA;override this.FuzzyBatchSearch : Azure.WaitUntil * seq&lt;Azure.Maps.Search.Models.FuzzySearchQuery&gt; * System.Threading.CancellationToken -&gt; Azure.Maps.Search.FuzzySearchBatchOperation" Usage="mapsSearchClient.FuzzyBatchSearch (waitUntil, queries, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Maps.Search.FuzzySearchBatchOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitUntil" Type="Azure.WaitUntil" />
        <Parameter Name="queries" Type="System.Collections.Generic.IEnumerable&lt;Azure.Maps.Search.Models.FuzzySearchQuery&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="waitUntil">
          <see cref="F:Azure.WaitUntil.Completed" /> if the method should wait to return until the long-running operation has completed on the service; <see cref="F:Azure.WaitUntil.Started" /> if it should return immediately after starting the operation. </param>
        <param name="queries"> The list of search fuzzy queries/requests to process. The list can contain a max of 10,000 queries and must contain at least 1 query. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            The Search Address Batch API sends batches of queries to <see href="https://docs.microsoft.com/rest/api/maps/search/getsearchfuzzy">Search Fuzzy API</see> using just a single API call. You can call Search Address Fuzzy Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="queries" /> is null. </exception>
      </Docs>
    </Member>
    <Member MemberName="FuzzyBatchSearchAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Maps.Search.FuzzySearchBatchOperation&gt; FuzzyBatchSearchAsync (Azure.WaitUntil waitUntil, System.Collections.Generic.IEnumerable&lt;Azure.Maps.Search.Models.FuzzySearchQuery&gt; queries, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Maps.Search.FuzzySearchBatchOperation&gt; FuzzyBatchSearchAsync(valuetype Azure.WaitUntil waitUntil, class System.Collections.Generic.IEnumerable`1&lt;class Azure.Maps.Search.Models.FuzzySearchQuery&gt; queries, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.FuzzyBatchSearchAsync(Azure.WaitUntil,System.Collections.Generic.IEnumerable{Azure.Maps.Search.Models.FuzzySearchQuery},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FuzzyBatchSearchAsync (waitUntil As WaitUntil, queries As IEnumerable(Of FuzzySearchQuery), Optional cancellationToken As CancellationToken = Nothing) As Task(Of FuzzySearchBatchOperation)" />
      <MemberSignature Language="F#" Value="abstract member FuzzyBatchSearchAsync : Azure.WaitUntil * seq&lt;Azure.Maps.Search.Models.FuzzySearchQuery&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Maps.Search.FuzzySearchBatchOperation&gt;&#xA;override this.FuzzyBatchSearchAsync : Azure.WaitUntil * seq&lt;Azure.Maps.Search.Models.FuzzySearchQuery&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Maps.Search.FuzzySearchBatchOperation&gt;" Usage="mapsSearchClient.FuzzyBatchSearchAsync (waitUntil, queries, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Maps.Search.FuzzySearchBatchOperation&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitUntil" Type="Azure.WaitUntil" />
        <Parameter Name="queries" Type="System.Collections.Generic.IEnumerable&lt;Azure.Maps.Search.Models.FuzzySearchQuery&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="waitUntil">
          <see cref="F:Azure.WaitUntil.Completed" /> if the method should wait to return until the long-running operation has completed on the service; <see cref="F:Azure.WaitUntil.Started" /> if it should return immediately after starting the operation. </param>
        <param name="queries"> The list of search fuzzy queries/requests to process. The list can contain a max of 10,000 queries and must contain at least 1 query. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            The Search Address Batch API sends batches of queries to <see href="https://docs.microsoft.com/rest/api/maps/search/getsearchfuzzy">Search Fuzzy API</see> using just a single API call. You can call Search Address Fuzzy Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="queries" /> is null. </exception>
      </Docs>
    </Member>
    <Member MemberName="FuzzySearch">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt; FuzzySearch (string query, Azure.Maps.Search.FuzzySearchOptions options = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Maps.Search.Models.SearchAddressResult&gt; FuzzySearch(string query, class Azure.Maps.Search.FuzzySearchOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.FuzzySearch(System.String,Azure.Maps.Search.FuzzySearchOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FuzzySearch (query As String, Optional options As FuzzySearchOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of SearchAddressResult)" />
      <MemberSignature Language="F#" Value="abstract member FuzzySearch : string * Azure.Maps.Search.FuzzySearchOptions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&#xA;override this.FuzzySearch : string * Azure.Maps.Search.FuzzySearchOptions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;" Usage="mapsSearchClient.FuzzySearch (query, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="options" Type="Azure.Maps.Search.FuzzySearchOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="query"> The POI name to search for (e.g., "statue of liberty", "starbucks"), must be properly URL encoded. </param>
        <param name="options"> additional options  </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            The basic default API is Free Form Search which handles the most fuzzy of inputs handling any combination of address or POI tokens. This search API is the canonical 'single line search'. The Free Form Search API is a seamless combination of POI search and geocoding. The API can also be weighted with a contextual position (lat./lon. pair), or fully constrained by a a pair of coordinates and radius, or it can be executed more generally without any geo biasing anchor point.&lt;br&gt;&lt;br&gt;We strongly advise you to use the 'countrySet' parameter to specify only the countries for which your application needs coverage, as the default behavior will be to search the entire world, potentially returning unnecessary results.&lt;br&gt;&lt;br&gt; E.g.: `countrySet`=US,FR &lt;br&gt;&lt;br&gt;Please see <see href="https://docs.microsoft.com/azure/location-based-services/geocoding-coverage">Search Coverage</see> for a complete list of all the supported countries.&lt;br&gt;&lt;br&gt;Most Search queries default to `maxFuzzyLevel`=2 to gain performance and also reduce unusual results. This new default can be overridden as needed per request by passing in the query param `maxFuzzyLevel`=3 or 4.
            </summary>
        <returns>To be added.</returns>
        <remarks>
             **Free Form Search**
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="FuzzySearchAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt; FuzzySearchAsync (string query, Azure.Maps.Search.FuzzySearchOptions options = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Maps.Search.Models.SearchAddressResult&gt;&gt; FuzzySearchAsync(string query, class Azure.Maps.Search.FuzzySearchOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.FuzzySearchAsync(System.String,Azure.Maps.Search.FuzzySearchOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FuzzySearchAsync (query As String, Optional options As FuzzySearchOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of SearchAddressResult))" />
      <MemberSignature Language="F#" Value="abstract member FuzzySearchAsync : string * Azure.Maps.Search.FuzzySearchOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;&#xA;override this.FuzzySearchAsync : string * Azure.Maps.Search.FuzzySearchOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;" Usage="mapsSearchClient.FuzzySearchAsync (query, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="options" Type="Azure.Maps.Search.FuzzySearchOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="query"> The POI name to search for (e.g., "statue of liberty", "starbucks"), must be properly URL encoded. </param>
        <param name="options"> additional options  </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            The basic default API is Free Form Search which handles the most fuzzy of inputs handling any combination of address or POI tokens. This search API is the canonical 'single line search'. The Free Form Search API is a seamless combination of POI search and geocoding. The API can also be weighted with a contextual position (lat./lon. pair), or fully constrained by a a pair of coordinates and radius, or it can be executed more generally without any geo biasing anchor point.&lt;br&gt;&lt;br&gt;We strongly advise you to use the 'countrySet' parameter to specify only the countries for which your application needs coverage, as the default behavior will be to search the entire world, potentially returning unnecessary results.&lt;br&gt;&lt;br&gt; E.g.: `countrySet`=US,FR &lt;br&gt;&lt;br&gt;Please see <see href="https://docs.microsoft.com/azure/location-based-services/geocoding-coverage">Search Coverage</see> for a complete list of all the supported countries.&lt;br&gt;&lt;br&gt;Most Search queries default to `maxFuzzyLevel`=2 to gain performance and also reduce unusual results. This new default can be overridden as needed per request by passing in the query param `maxFuzzyLevel`=3 or 4.
            </summary>
        <returns>To be added.</returns>
        <remarks>
             **Free Form Search**
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetImmediateFuzzyBatchSearch">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressBatchResult&gt; GetImmediateFuzzyBatchSearch (System.Collections.Generic.IEnumerable&lt;Azure.Maps.Search.Models.FuzzySearchQuery&gt; queries, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Maps.Search.Models.SearchAddressBatchResult&gt; GetImmediateFuzzyBatchSearch(class System.Collections.Generic.IEnumerable`1&lt;class Azure.Maps.Search.Models.FuzzySearchQuery&gt; queries, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.GetImmediateFuzzyBatchSearch(System.Collections.Generic.IEnumerable{Azure.Maps.Search.Models.FuzzySearchQuery},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetImmediateFuzzyBatchSearch (queries As IEnumerable(Of FuzzySearchQuery), Optional cancellationToken As CancellationToken = Nothing) As Response(Of SearchAddressBatchResult)" />
      <MemberSignature Language="F#" Value="abstract member GetImmediateFuzzyBatchSearch : seq&lt;Azure.Maps.Search.Models.FuzzySearchQuery&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressBatchResult&gt;&#xA;override this.GetImmediateFuzzyBatchSearch : seq&lt;Azure.Maps.Search.Models.FuzzySearchQuery&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressBatchResult&gt;" Usage="mapsSearchClient.GetImmediateFuzzyBatchSearch (queries, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressBatchResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queries" Type="System.Collections.Generic.IEnumerable&lt;Azure.Maps.Search.Models.FuzzySearchQuery&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="queries"> The list of search fuzzy queries/requests to process. The list can contain  a max of 10,000 queries and must contain at least 1 query. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            The Search Address Batch API sends batches of queries to <see href="https://docs.microsoft.com/rest/api/maps/search/getsearchfuzzy">Search Fuzzy API</see> using just a single API call. You can call Search Address Fuzzy Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetImmediateFuzzyBatchSearchAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressBatchResult&gt;&gt; GetImmediateFuzzyBatchSearchAsync (System.Collections.Generic.IEnumerable&lt;Azure.Maps.Search.Models.FuzzySearchQuery&gt; queries, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Maps.Search.Models.SearchAddressBatchResult&gt;&gt; GetImmediateFuzzyBatchSearchAsync(class System.Collections.Generic.IEnumerable`1&lt;class Azure.Maps.Search.Models.FuzzySearchQuery&gt; queries, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.GetImmediateFuzzyBatchSearchAsync(System.Collections.Generic.IEnumerable{Azure.Maps.Search.Models.FuzzySearchQuery},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetImmediateFuzzyBatchSearchAsync (queries As IEnumerable(Of FuzzySearchQuery), Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of SearchAddressBatchResult))" />
      <MemberSignature Language="F#" Value="abstract member GetImmediateFuzzyBatchSearchAsync : seq&lt;Azure.Maps.Search.Models.FuzzySearchQuery&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressBatchResult&gt;&gt;&#xA;override this.GetImmediateFuzzyBatchSearchAsync : seq&lt;Azure.Maps.Search.Models.FuzzySearchQuery&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressBatchResult&gt;&gt;" Usage="mapsSearchClient.GetImmediateFuzzyBatchSearchAsync (queries, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressBatchResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queries" Type="System.Collections.Generic.IEnumerable&lt;Azure.Maps.Search.Models.FuzzySearchQuery&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="queries"> The list of search fuzzy queries/requests to process. The list can contain  a max of 10,000 queries and must contain at least 1 query. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            The Search Address Batch API sends batches of queries to <see href="https://docs.microsoft.com/rest/api/maps/search/getsearchfuzzy">Search Fuzzy API</see> using just a single API call. You can call Search Address Fuzzy Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetImmediateReverseSearchAddressBatch">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Maps.Search.Models.ReverseSearchAddressBatchResult&gt; GetImmediateReverseSearchAddressBatch (System.Collections.Generic.IEnumerable&lt;Azure.Maps.Search.ReverseSearchAddressQuery&gt; queries, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Maps.Search.Models.ReverseSearchAddressBatchResult&gt; GetImmediateReverseSearchAddressBatch(class System.Collections.Generic.IEnumerable`1&lt;class Azure.Maps.Search.ReverseSearchAddressQuery&gt; queries, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.GetImmediateReverseSearchAddressBatch(System.Collections.Generic.IEnumerable{Azure.Maps.Search.ReverseSearchAddressQuery},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetImmediateReverseSearchAddressBatch (queries As IEnumerable(Of ReverseSearchAddressQuery), Optional cancellationToken As CancellationToken = Nothing) As Response(Of ReverseSearchAddressBatchResult)" />
      <MemberSignature Language="F#" Value="abstract member GetImmediateReverseSearchAddressBatch : seq&lt;Azure.Maps.Search.ReverseSearchAddressQuery&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.ReverseSearchAddressBatchResult&gt;&#xA;override this.GetImmediateReverseSearchAddressBatch : seq&lt;Azure.Maps.Search.ReverseSearchAddressQuery&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.ReverseSearchAddressBatchResult&gt;" Usage="mapsSearchClient.GetImmediateReverseSearchAddressBatch (queries, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Maps.Search.Models.ReverseSearchAddressBatchResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queries" Type="System.Collections.Generic.IEnumerable&lt;Azure.Maps.Search.ReverseSearchAddressQuery&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="queries"> The list of reverse geocoding queries/requests to process. The list can contain  a max of 10,000 queries and must contain at least 1 query. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            The Search Address Batch API sends batches of queries to <see href="https://docs.microsoft.com/rest/api/maps/search/getsearchaddressreverse">Search Address Reverse API</see> using just a single API call. This Search Address Reverse Batch API can handle up to **100** queries.
            To send more queries in a batch request, please refer to <see cref="M:Azure.Maps.Search.MapsSearchClient.ReverseSearchAddressBatch(Azure.WaitUntil,System.Collections.Generic.IEnumerable{Azure.Maps.Search.ReverseSearchAddressQuery},System.Threading.CancellationToken)" /> long-running operation.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetImmediateReverseSearchAddressBatchAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.ReverseSearchAddressBatchResult&gt;&gt; GetImmediateReverseSearchAddressBatchAsync (System.Collections.Generic.IEnumerable&lt;Azure.Maps.Search.ReverseSearchAddressQuery&gt; queries, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Maps.Search.Models.ReverseSearchAddressBatchResult&gt;&gt; GetImmediateReverseSearchAddressBatchAsync(class System.Collections.Generic.IEnumerable`1&lt;class Azure.Maps.Search.ReverseSearchAddressQuery&gt; queries, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.GetImmediateReverseSearchAddressBatchAsync(System.Collections.Generic.IEnumerable{Azure.Maps.Search.ReverseSearchAddressQuery},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetImmediateReverseSearchAddressBatchAsync (queries As IEnumerable(Of ReverseSearchAddressQuery), Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of ReverseSearchAddressBatchResult))" />
      <MemberSignature Language="F#" Value="abstract member GetImmediateReverseSearchAddressBatchAsync : seq&lt;Azure.Maps.Search.ReverseSearchAddressQuery&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.ReverseSearchAddressBatchResult&gt;&gt;&#xA;override this.GetImmediateReverseSearchAddressBatchAsync : seq&lt;Azure.Maps.Search.ReverseSearchAddressQuery&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.ReverseSearchAddressBatchResult&gt;&gt;" Usage="mapsSearchClient.GetImmediateReverseSearchAddressBatchAsync (queries, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.ReverseSearchAddressBatchResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queries" Type="System.Collections.Generic.IEnumerable&lt;Azure.Maps.Search.ReverseSearchAddressQuery&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="queries"> The list of reverse geocoding queries/requests to process. The list can contain  a max of 10,000 queries and must contain at least 1 query. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            The Search Address Batch API sends batches of queries to <see href="https://docs.microsoft.com/rest/api/maps/search/getsearchaddressreverse">Search Address Reverse API</see> using just a single API call. This Search Address Reverse Batch API can handle up to **100** queries.
            To send more queries in a batch request, please refer to <see cref="M:Azure.Maps.Search.MapsSearchClient.ReverseSearchAddressBatch(Azure.WaitUntil,System.Collections.Generic.IEnumerable{Azure.Maps.Search.ReverseSearchAddressQuery},System.Threading.CancellationToken)" /> long-running operation.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetImmediateSearchAddressBatch">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressBatchResult&gt; GetImmediateSearchAddressBatch (System.Collections.Generic.IEnumerable&lt;Azure.Maps.Search.SearchAddressQuery&gt; queries, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Maps.Search.Models.SearchAddressBatchResult&gt; GetImmediateSearchAddressBatch(class System.Collections.Generic.IEnumerable`1&lt;class Azure.Maps.Search.SearchAddressQuery&gt; queries, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.GetImmediateSearchAddressBatch(System.Collections.Generic.IEnumerable{Azure.Maps.Search.SearchAddressQuery},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetImmediateSearchAddressBatch (queries As IEnumerable(Of SearchAddressQuery), Optional cancellationToken As CancellationToken = Nothing) As Response(Of SearchAddressBatchResult)" />
      <MemberSignature Language="F#" Value="abstract member GetImmediateSearchAddressBatch : seq&lt;Azure.Maps.Search.SearchAddressQuery&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressBatchResult&gt;&#xA;override this.GetImmediateSearchAddressBatch : seq&lt;Azure.Maps.Search.SearchAddressQuery&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressBatchResult&gt;" Usage="mapsSearchClient.GetImmediateSearchAddressBatch (queries, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressBatchResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queries" Type="System.Collections.Generic.IEnumerable&lt;Azure.Maps.Search.SearchAddressQuery&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="queries"> The list of address geocoding queries/requests to process. The list can contain  a max of 10,000 queries and must contain at least 1 query. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            The Search Address Batch API sends batches of queries to <see href="https://docs.microsoft.com/rest/api/maps/search/getsearchaddress">Search Address API</see> using just a single API call. You can call Search Address Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
            To send more queries in a batch request, please refer to <see cref="M:Azure.Maps.Search.MapsSearchClient.SearchAddressBatch(Azure.WaitUntil,System.Collections.Generic.IEnumerable{Azure.Maps.Search.SearchAddressQuery},System.Threading.CancellationToken)" /> long-running operation.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetImmediateSearchAddressBatchAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressBatchResult&gt;&gt; GetImmediateSearchAddressBatchAsync (System.Collections.Generic.IEnumerable&lt;Azure.Maps.Search.SearchAddressQuery&gt; queries, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Maps.Search.Models.SearchAddressBatchResult&gt;&gt; GetImmediateSearchAddressBatchAsync(class System.Collections.Generic.IEnumerable`1&lt;class Azure.Maps.Search.SearchAddressQuery&gt; queries, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.GetImmediateSearchAddressBatchAsync(System.Collections.Generic.IEnumerable{Azure.Maps.Search.SearchAddressQuery},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetImmediateSearchAddressBatchAsync (queries As IEnumerable(Of SearchAddressQuery), Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of SearchAddressBatchResult))" />
      <MemberSignature Language="F#" Value="abstract member GetImmediateSearchAddressBatchAsync : seq&lt;Azure.Maps.Search.SearchAddressQuery&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressBatchResult&gt;&gt;&#xA;override this.GetImmediateSearchAddressBatchAsync : seq&lt;Azure.Maps.Search.SearchAddressQuery&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressBatchResult&gt;&gt;" Usage="mapsSearchClient.GetImmediateSearchAddressBatchAsync (queries, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressBatchResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queries" Type="System.Collections.Generic.IEnumerable&lt;Azure.Maps.Search.SearchAddressQuery&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="queries"> The list of address geocoding queries/requests to process. The list can contain  a max of 10,000 queries and must contain at least 1 query. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            The Search Address Batch API sends batches of queries to <see href="https://docs.microsoft.com/rest/api/maps/search/getsearchaddress">Search Address API</see> using just a single API call. This Search Address Batch API can handle up to **100** queries.
            To send more queries in a batch request, please refer to <see cref="M:Azure.Maps.Search.MapsSearchClient.SearchAddressBatch(Azure.WaitUntil,System.Collections.Generic.IEnumerable{Azure.Maps.Search.SearchAddressQuery},System.Threading.CancellationToken)" /> long-running operation.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPointOfInterestCategoryTree">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Maps.Search.Models.PointOfInterestCategoryTreeResult&gt; GetPointOfInterestCategoryTree (Azure.Maps.Search.SearchLanguage? language = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Maps.Search.Models.PointOfInterestCategoryTreeResult&gt; GetPointOfInterestCategoryTree(valuetype System.Nullable`1&lt;valuetype Azure.Maps.Search.SearchLanguage&gt; language, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.GetPointOfInterestCategoryTree(System.Nullable{Azure.Maps.Search.SearchLanguage},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPointOfInterestCategoryTree (Optional language As Nullable(Of SearchLanguage) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of PointOfInterestCategoryTreeResult)" />
      <MemberSignature Language="F#" Value="abstract member GetPointOfInterestCategoryTree : Nullable&lt;Azure.Maps.Search.SearchLanguage&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.PointOfInterestCategoryTreeResult&gt;&#xA;override this.GetPointOfInterestCategoryTree : Nullable&lt;Azure.Maps.Search.SearchLanguage&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.PointOfInterestCategoryTreeResult&gt;" Usage="mapsSearchClient.GetPointOfInterestCategoryTree (language, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Maps.Search.Models.PointOfInterestCategoryTreeResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.Nullable&lt;Azure.Maps.Search.SearchLanguage&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="language">
            Language in which search results should be returned. Should be one of supported IETF language tags, except NGT and NGT-Latn. Language tag is case insensitive. When data in specified language is not available for a specific field, default language is used (English).
            Please refer to <see href="https://docs.microsoft.com/azure/azure-maps/supported-languages">Supported Languages</see> for details.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Get POI Category Tree API. POI Category API provides a full list of supported Points of Interest (POI) categories and subcategories together with their translations and synonyms. The returned content can be used to provide more meaningful results through other Search Service APIs, like <see href="https://docs.microsoft.com/rest/api/maps/search/getsearchpoi">Get Search POI</see>.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPointOfInterestCategoryTreeAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.PointOfInterestCategoryTreeResult&gt;&gt; GetPointOfInterestCategoryTreeAsync (Azure.Maps.Search.SearchLanguage? language = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Maps.Search.Models.PointOfInterestCategoryTreeResult&gt;&gt; GetPointOfInterestCategoryTreeAsync(valuetype System.Nullable`1&lt;valuetype Azure.Maps.Search.SearchLanguage&gt; language, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.GetPointOfInterestCategoryTreeAsync(System.Nullable{Azure.Maps.Search.SearchLanguage},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPointOfInterestCategoryTreeAsync (Optional language As Nullable(Of SearchLanguage) = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of PointOfInterestCategoryTreeResult))" />
      <MemberSignature Language="F#" Value="abstract member GetPointOfInterestCategoryTreeAsync : Nullable&lt;Azure.Maps.Search.SearchLanguage&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.PointOfInterestCategoryTreeResult&gt;&gt;&#xA;override this.GetPointOfInterestCategoryTreeAsync : Nullable&lt;Azure.Maps.Search.SearchLanguage&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.PointOfInterestCategoryTreeResult&gt;&gt;" Usage="mapsSearchClient.GetPointOfInterestCategoryTreeAsync (language, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.PointOfInterestCategoryTreeResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="language" Type="System.Nullable&lt;Azure.Maps.Search.SearchLanguage&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="language">
            Language in which search results should be returned. Should be one of supported IETF language tags, except NGT and NGT-Latn. Language tag is case insensitive. When data in specified language is not available for a specific field, default language is used (English).
            Please refer to <see href="https://docs.microsoft.com/azure/azure-maps/supported-languages">Supported Languages</see> for details.
            </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Get POI Category Tree API. POI Category API provides a full list of supported Points of Interest (POI) categories and subcategories together with their translations and synonyms. The returned content can be used to provide more meaningful results through other Search Service APIs, like <see href="https://docs.microsoft.com/rest/api/maps/search/getsearchpoi">Get Search POI</see>.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPolygons">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Maps.Search.Models.PolygonResult&gt; GetPolygons (System.Collections.Generic.IEnumerable&lt;string&gt; geometryIds, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Maps.Search.Models.PolygonResult&gt; GetPolygons(class System.Collections.Generic.IEnumerable`1&lt;string&gt; geometryIds, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.GetPolygons(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPolygons (geometryIds As IEnumerable(Of String), Optional cancellationToken As CancellationToken = Nothing) As Response(Of PolygonResult)" />
      <MemberSignature Language="F#" Value="abstract member GetPolygons : seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.PolygonResult&gt;&#xA;override this.GetPolygons : seq&lt;string&gt; * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.PolygonResult&gt;" Usage="mapsSearchClient.GetPolygons (geometryIds, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Maps.Search.Models.PolygonResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="geometryIds" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="geometryIds"> Comma separated list of geometry UUIDs, previously retrieved from an Online Search request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            The Get Polygon service allows you to request the geometry data such as a city or country  outline for a set of entities, previously retrieved from an Online Search request in GeoJSON format. The geometry ID is returned in the sourceGeometry object under "geometry" and "id" in either a Search Address or Search Fuzzy call.
            </summary>
        <returns>To be added.</returns>
        <remarks>
             **Get Polygon**
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPolygonsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.PolygonResult&gt;&gt; GetPolygonsAsync (System.Collections.Generic.IEnumerable&lt;string&gt; geometryIds, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Maps.Search.Models.PolygonResult&gt;&gt; GetPolygonsAsync(class System.Collections.Generic.IEnumerable`1&lt;string&gt; geometryIds, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.GetPolygonsAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPolygonsAsync (geometryIds As IEnumerable(Of String), Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of PolygonResult))" />
      <MemberSignature Language="F#" Value="abstract member GetPolygonsAsync : seq&lt;string&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.PolygonResult&gt;&gt;&#xA;override this.GetPolygonsAsync : seq&lt;string&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.PolygonResult&gt;&gt;" Usage="mapsSearchClient.GetPolygonsAsync (geometryIds, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.PolygonResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="geometryIds" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="geometryIds"> Comma separated list of geometry UUIDs, previously retrieved from an Online Search request. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            The Get Polygon service allows you to request the geometry data such as a city or country  outline for a set of entities, previously retrieved from an Online Search request in GeoJSON format. The geometry ID is returned in the sourceGeometry object under "geometry" and "id" in either a Search Address or Search Fuzzy call.
            </summary>
        <returns>To be added.</returns>
        <remarks>
             **Get Polygon**
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseSearchAddress">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Maps.Search.Models.ReverseSearchAddressResult&gt; ReverseSearchAddress (Azure.Maps.Search.ReverseSearchOptions options = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Maps.Search.Models.ReverseSearchAddressResult&gt; ReverseSearchAddress(class Azure.Maps.Search.ReverseSearchOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.ReverseSearchAddress(Azure.Maps.Search.ReverseSearchOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReverseSearchAddress (Optional options As ReverseSearchOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of ReverseSearchAddressResult)" />
      <MemberSignature Language="F#" Value="abstract member ReverseSearchAddress : Azure.Maps.Search.ReverseSearchOptions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.ReverseSearchAddressResult&gt;&#xA;override this.ReverseSearchAddress : Azure.Maps.Search.ReverseSearchOptions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.ReverseSearchAddressResult&gt;" Usage="mapsSearchClient.ReverseSearchAddress (options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Maps.Search.Models.ReverseSearchAddressResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="Azure.Maps.Search.ReverseSearchOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="options"> additional options  </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Reverse geocode to an address. There may be times when you need to translate a pair of coordinates (example: 37.786505, -122.3862) into a human understandable street address. Most often  this is needed in tracking applications where you  receive a GPS feed from the device or asset and  wish to know what address where the a pair of coordinates is  located. This endpoint will return address  information for a given coordinate.
            </summary>
        <returns>To be added.</returns>
        <remarks>
             **Reverse Geocode to an Address**
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseSearchAddressAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.ReverseSearchAddressResult&gt;&gt; ReverseSearchAddressAsync (Azure.Maps.Search.ReverseSearchOptions options = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Maps.Search.Models.ReverseSearchAddressResult&gt;&gt; ReverseSearchAddressAsync(class Azure.Maps.Search.ReverseSearchOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.ReverseSearchAddressAsync(Azure.Maps.Search.ReverseSearchOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReverseSearchAddressAsync (Optional options As ReverseSearchOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of ReverseSearchAddressResult))" />
      <MemberSignature Language="F#" Value="abstract member ReverseSearchAddressAsync : Azure.Maps.Search.ReverseSearchOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.ReverseSearchAddressResult&gt;&gt;&#xA;override this.ReverseSearchAddressAsync : Azure.Maps.Search.ReverseSearchOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.ReverseSearchAddressResult&gt;&gt;" Usage="mapsSearchClient.ReverseSearchAddressAsync (options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.ReverseSearchAddressResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="Azure.Maps.Search.ReverseSearchOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="options"> additional options  </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Reverse geocode to an address. There may be times when you need to translate a pair of coordinates (example: 37.786505, -122.3862) into a human understandable street address. Most often  this is needed in tracking applications where you  receive a GPS feed from the device or asset and  wish to know what address where the a pair of coordinates is  located. This endpoint will return address  information for a given coordinate.
            </summary>
        <returns>To be added.</returns>
        <remarks>
             **Reverse Geocode to an Address**
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseSearchAddressBatch">
      <MemberSignature Language="C#" Value="public virtual Azure.Maps.Search.ReverseSearchAddressBatchOperation ReverseSearchAddressBatch (Azure.WaitUntil waitUntil, System.Collections.Generic.IEnumerable&lt;Azure.Maps.Search.ReverseSearchAddressQuery&gt; queries, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Maps.Search.ReverseSearchAddressBatchOperation ReverseSearchAddressBatch(valuetype Azure.WaitUntil waitUntil, class System.Collections.Generic.IEnumerable`1&lt;class Azure.Maps.Search.ReverseSearchAddressQuery&gt; queries, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.ReverseSearchAddressBatch(Azure.WaitUntil,System.Collections.Generic.IEnumerable{Azure.Maps.Search.ReverseSearchAddressQuery},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReverseSearchAddressBatch (waitUntil As WaitUntil, queries As IEnumerable(Of ReverseSearchAddressQuery), Optional cancellationToken As CancellationToken = Nothing) As ReverseSearchAddressBatchOperation" />
      <MemberSignature Language="F#" Value="abstract member ReverseSearchAddressBatch : Azure.WaitUntil * seq&lt;Azure.Maps.Search.ReverseSearchAddressQuery&gt; * System.Threading.CancellationToken -&gt; Azure.Maps.Search.ReverseSearchAddressBatchOperation&#xA;override this.ReverseSearchAddressBatch : Azure.WaitUntil * seq&lt;Azure.Maps.Search.ReverseSearchAddressQuery&gt; * System.Threading.CancellationToken -&gt; Azure.Maps.Search.ReverseSearchAddressBatchOperation" Usage="mapsSearchClient.ReverseSearchAddressBatch (waitUntil, queries, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Maps.Search.ReverseSearchAddressBatchOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitUntil" Type="Azure.WaitUntil" />
        <Parameter Name="queries" Type="System.Collections.Generic.IEnumerable&lt;Azure.Maps.Search.ReverseSearchAddressQuery&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="waitUntil">
          <see cref="F:Azure.WaitUntil.Completed" /> if the method should wait to return until the long-running operation has completed on the service; <see cref="F:Azure.WaitUntil.Started" /> if it should return immediately after starting the operation. </param>
        <param name="queries"> The list of reverse geocoding queries/requests to process. The list can contain  a max of 10,000 queries and must contain at least 1 query. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            The Search Address Reverse Batch API sends batches of queries to <see href="https://docs.microsoft.com/rest/api/maps/search/getsearchaddressreverse">Search Address Reverse API</see> using just a single API call. You can call Search Address Reverse Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="queries" /> is null. </exception>
      </Docs>
    </Member>
    <Member MemberName="ReverseSearchAddressBatchAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Maps.Search.ReverseSearchAddressBatchOperation&gt; ReverseSearchAddressBatchAsync (Azure.WaitUntil waitUntil, System.Collections.Generic.IEnumerable&lt;Azure.Maps.Search.ReverseSearchAddressQuery&gt; queries, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Maps.Search.ReverseSearchAddressBatchOperation&gt; ReverseSearchAddressBatchAsync(valuetype Azure.WaitUntil waitUntil, class System.Collections.Generic.IEnumerable`1&lt;class Azure.Maps.Search.ReverseSearchAddressQuery&gt; queries, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.ReverseSearchAddressBatchAsync(Azure.WaitUntil,System.Collections.Generic.IEnumerable{Azure.Maps.Search.ReverseSearchAddressQuery},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReverseSearchAddressBatchAsync (waitUntil As WaitUntil, queries As IEnumerable(Of ReverseSearchAddressQuery), Optional cancellationToken As CancellationToken = Nothing) As Task(Of ReverseSearchAddressBatchOperation)" />
      <MemberSignature Language="F#" Value="abstract member ReverseSearchAddressBatchAsync : Azure.WaitUntil * seq&lt;Azure.Maps.Search.ReverseSearchAddressQuery&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Maps.Search.ReverseSearchAddressBatchOperation&gt;&#xA;override this.ReverseSearchAddressBatchAsync : Azure.WaitUntil * seq&lt;Azure.Maps.Search.ReverseSearchAddressQuery&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Maps.Search.ReverseSearchAddressBatchOperation&gt;" Usage="mapsSearchClient.ReverseSearchAddressBatchAsync (waitUntil, queries, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Maps.Search.ReverseSearchAddressBatchOperation&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitUntil" Type="Azure.WaitUntil" />
        <Parameter Name="queries" Type="System.Collections.Generic.IEnumerable&lt;Azure.Maps.Search.ReverseSearchAddressQuery&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="waitUntil">
          <see cref="F:Azure.WaitUntil.Completed" /> if the method should wait to return until the long-running operation has completed on the service; <see cref="F:Azure.WaitUntil.Started" /> if it should return immediately after starting the operation. </param>
        <param name="queries"> The list of reverse geocoding queries/requests to process. The list can contain  a max of 10,000 queries and must contain at least 1 query. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            The Search Address Reverse Batch API sends batches of queries to <see href="https://docs.microsoft.com/rest/api/maps/search/getsearchaddressreverse">Search Address Reverse API</see> using just a single API call. This Search Address Reverse Batch API can handle up to **10000** queries.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="queries" /> is null. </exception>
      </Docs>
    </Member>
    <Member MemberName="ReverseSearchCrossStreetAddress">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Maps.Search.Models.ReverseSearchCrossStreetAddressResult&gt; ReverseSearchCrossStreetAddress (Azure.Maps.Search.ReverseSearchCrossStreetOptions options = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Maps.Search.Models.ReverseSearchCrossStreetAddressResult&gt; ReverseSearchCrossStreetAddress(class Azure.Maps.Search.ReverseSearchCrossStreetOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.ReverseSearchCrossStreetAddress(Azure.Maps.Search.ReverseSearchCrossStreetOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReverseSearchCrossStreetAddress (Optional options As ReverseSearchCrossStreetOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of ReverseSearchCrossStreetAddressResult)" />
      <MemberSignature Language="F#" Value="abstract member ReverseSearchCrossStreetAddress : Azure.Maps.Search.ReverseSearchCrossStreetOptions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.ReverseSearchCrossStreetAddressResult&gt;&#xA;override this.ReverseSearchCrossStreetAddress : Azure.Maps.Search.ReverseSearchCrossStreetOptions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.ReverseSearchCrossStreetAddressResult&gt;" Usage="mapsSearchClient.ReverseSearchCrossStreetAddress (options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Maps.Search.Models.ReverseSearchCrossStreetAddressResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="Azure.Maps.Search.ReverseSearchCrossStreetOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="options"> additional options  </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Reverse geocode to a cross street. There may be times when you need to translate a  a pair of coordinates (example: 37.786505, -122.3862) into a human understandable cross street. Most often this  is needed in tracking applications where you  receive a GPS feed from the device or asset and wish to know what address where the a pair of coordinates is  located.
            This endpoint will return cross street information  for a given coordinate.
            </summary>
        <returns>To be added.</returns>
        <remarks>
             **Reverse Geocode to a Cross Street**
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReverseSearchCrossStreetAddressAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.ReverseSearchCrossStreetAddressResult&gt;&gt; ReverseSearchCrossStreetAddressAsync (Azure.Maps.Search.ReverseSearchCrossStreetOptions options = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Maps.Search.Models.ReverseSearchCrossStreetAddressResult&gt;&gt; ReverseSearchCrossStreetAddressAsync(class Azure.Maps.Search.ReverseSearchCrossStreetOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.ReverseSearchCrossStreetAddressAsync(Azure.Maps.Search.ReverseSearchCrossStreetOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ReverseSearchCrossStreetAddressAsync (Optional options As ReverseSearchCrossStreetOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of ReverseSearchCrossStreetAddressResult))" />
      <MemberSignature Language="F#" Value="abstract member ReverseSearchCrossStreetAddressAsync : Azure.Maps.Search.ReverseSearchCrossStreetOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.ReverseSearchCrossStreetAddressResult&gt;&gt;&#xA;override this.ReverseSearchCrossStreetAddressAsync : Azure.Maps.Search.ReverseSearchCrossStreetOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.ReverseSearchCrossStreetAddressResult&gt;&gt;" Usage="mapsSearchClient.ReverseSearchCrossStreetAddressAsync (options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.ReverseSearchCrossStreetAddressResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="Azure.Maps.Search.ReverseSearchCrossStreetOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="options"> additional options  </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Reverse geocode to a cross street. There may be times when you need to translate a  a pair of coordinates (example: 37.786505, -122.3862) into a human understandable cross street. Most often this  is needed in tracking applications where you  receive a GPS feed from the device or asset and wish to know what address where the a pair of coordinates is  located.
            This endpoint will return cross street information  for a given coordinate.
            </summary>
        <returns>To be added.</returns>
        <remarks>
             **Reverse Geocode to a Cross Street**
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="SearchAddress">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt; SearchAddress (string query, Azure.Maps.Search.SearchAddressOptions options = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Maps.Search.Models.SearchAddressResult&gt; SearchAddress(string query, class Azure.Maps.Search.SearchAddressOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.SearchAddress(System.String,Azure.Maps.Search.SearchAddressOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SearchAddress (query As String, Optional options As SearchAddressOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of SearchAddressResult)" />
      <MemberSignature Language="F#" Value="abstract member SearchAddress : string * Azure.Maps.Search.SearchAddressOptions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&#xA;override this.SearchAddress : string * Azure.Maps.Search.SearchAddressOptions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;" Usage="mapsSearchClient.SearchAddress (query, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="options" Type="Azure.Maps.Search.SearchAddressOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="query"> The POI name to search for (e.g., "statue of liberty", "starbucks", "pizza"). Must be properly URL encoded. </param>
        <param name="options"> additional options  </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Address geocoding. The geocoding is performed by hitting the geocode endpoint with just the address or partial address in question. The geocoding search index will be queried for everything above the street level data. No POIs will be returned. Note that the geocoder is very tolerant of typos and incomplete addresses. It will also handle everything from exact street addresses or street or intersections as well as higher level geographies such as city centers, counties, states etc.
            </summary>
        <returns>To be added.</returns>
        <remarks>
             **Address Geocoding**
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="SearchAddressAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt; SearchAddressAsync (string query, Azure.Maps.Search.SearchAddressOptions options = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Maps.Search.Models.SearchAddressResult&gt;&gt; SearchAddressAsync(string query, class Azure.Maps.Search.SearchAddressOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.SearchAddressAsync(System.String,Azure.Maps.Search.SearchAddressOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SearchAddressAsync (query As String, Optional options As SearchAddressOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of SearchAddressResult))" />
      <MemberSignature Language="F#" Value="abstract member SearchAddressAsync : string * Azure.Maps.Search.SearchAddressOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;&#xA;override this.SearchAddressAsync : string * Azure.Maps.Search.SearchAddressOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;" Usage="mapsSearchClient.SearchAddressAsync (query, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="options" Type="Azure.Maps.Search.SearchAddressOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="query"> The POI name to search for (e.g., "statue of liberty", "starbucks", "pizza"). Must be properly URL encoded. </param>
        <param name="options"> additional options  </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Address geocoding. The geocoding is performed by hitting the geocode endpoint with just the address or partial address in question. The geocoding search index will be queried for everything above the street level data. No POIs will be returned. Note that the geocoder is very tolerant of typos and incomplete addresses. It will also handle everything from exact street addresses or street or intersections as well as higher level geographies such as city centers, counties, states etc.
            </summary>
        <returns>To be added.</returns>
        <remarks>
             **Address Geocoding**
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="SearchAddressBatch">
      <MemberSignature Language="C#" Value="public virtual Azure.Maps.Search.SearchAddressBatchOperation SearchAddressBatch (Azure.WaitUntil waitUntil, System.Collections.Generic.IEnumerable&lt;Azure.Maps.Search.SearchAddressQuery&gt; queries, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Maps.Search.SearchAddressBatchOperation SearchAddressBatch(valuetype Azure.WaitUntil waitUntil, class System.Collections.Generic.IEnumerable`1&lt;class Azure.Maps.Search.SearchAddressQuery&gt; queries, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.SearchAddressBatch(Azure.WaitUntil,System.Collections.Generic.IEnumerable{Azure.Maps.Search.SearchAddressQuery},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SearchAddressBatch (waitUntil As WaitUntil, queries As IEnumerable(Of SearchAddressQuery), Optional cancellationToken As CancellationToken = Nothing) As SearchAddressBatchOperation" />
      <MemberSignature Language="F#" Value="abstract member SearchAddressBatch : Azure.WaitUntil * seq&lt;Azure.Maps.Search.SearchAddressQuery&gt; * System.Threading.CancellationToken -&gt; Azure.Maps.Search.SearchAddressBatchOperation&#xA;override this.SearchAddressBatch : Azure.WaitUntil * seq&lt;Azure.Maps.Search.SearchAddressQuery&gt; * System.Threading.CancellationToken -&gt; Azure.Maps.Search.SearchAddressBatchOperation" Usage="mapsSearchClient.SearchAddressBatch (waitUntil, queries, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Maps.Search.SearchAddressBatchOperation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitUntil" Type="Azure.WaitUntil" />
        <Parameter Name="queries" Type="System.Collections.Generic.IEnumerable&lt;Azure.Maps.Search.SearchAddressQuery&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="waitUntil">
          <see cref="F:Azure.WaitUntil.Completed" /> if the method should wait to return until the long-running operation has completed on the service; <see cref="F:Azure.WaitUntil.Started" /> if it should return immediately after starting the operation. </param>
        <param name="queries"> The list of address geocoding queries/requests to process. The list can contain  a max of 10,000 queries and must contain at least 1 query. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            The Search Address Batch API sends batches of queries to <see href="https://docs.microsoft.com/rest/api/maps/search/getsearchaddress">Search Address API</see> using just a single API call. You can call Search Address Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="queries" /> is null. </exception>
      </Docs>
    </Member>
    <Member MemberName="SearchAddressBatchAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Maps.Search.SearchAddressBatchOperation&gt; SearchAddressBatchAsync (Azure.WaitUntil waitUntil, System.Collections.Generic.IEnumerable&lt;Azure.Maps.Search.SearchAddressQuery&gt; queries, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Maps.Search.SearchAddressBatchOperation&gt; SearchAddressBatchAsync(valuetype Azure.WaitUntil waitUntil, class System.Collections.Generic.IEnumerable`1&lt;class Azure.Maps.Search.SearchAddressQuery&gt; queries, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.SearchAddressBatchAsync(Azure.WaitUntil,System.Collections.Generic.IEnumerable{Azure.Maps.Search.SearchAddressQuery},System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SearchAddressBatchAsync (waitUntil As WaitUntil, queries As IEnumerable(Of SearchAddressQuery), Optional cancellationToken As CancellationToken = Nothing) As Task(Of SearchAddressBatchOperation)" />
      <MemberSignature Language="F#" Value="abstract member SearchAddressBatchAsync : Azure.WaitUntil * seq&lt;Azure.Maps.Search.SearchAddressQuery&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Maps.Search.SearchAddressBatchOperation&gt;&#xA;override this.SearchAddressBatchAsync : Azure.WaitUntil * seq&lt;Azure.Maps.Search.SearchAddressQuery&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Maps.Search.SearchAddressBatchOperation&gt;" Usage="mapsSearchClient.SearchAddressBatchAsync (waitUntil, queries, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Maps.Search.SearchAddressBatchOperation&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitUntil" Type="Azure.WaitUntil" />
        <Parameter Name="queries" Type="System.Collections.Generic.IEnumerable&lt;Azure.Maps.Search.SearchAddressQuery&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="waitUntil">
          <see cref="F:Azure.WaitUntil.Completed" /> if the method should wait to return until the long-running operation has completed on the service; <see cref="F:Azure.WaitUntil.Started" /> if it should return immediately after starting the operation. </param>
        <param name="queries"> The list of address geocoding queries/requests to process. The list can contain  a max of 10,000 queries and must contain at least 1 query. </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            The Search Address Batch API sends batches of queries to <see href="https://docs.microsoft.com/rest/api/maps/search/getsearchfuzzy">Search Fuzzy API</see> using just a single API call. You can call Search Address Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **10,000** queries and sync API up to **100** queries.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="queries" /> is null. </exception>
      </Docs>
    </Member>
    <Member MemberName="SearchInsideGeometry">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt; SearchInsideGeometry (string query, Azure.Core.GeoJson.GeoCollection geometryCollection, Azure.Maps.Search.SearchInsideGeometryOptions options = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Maps.Search.Models.SearchAddressResult&gt; SearchInsideGeometry(string query, class Azure.Core.GeoJson.GeoCollection geometryCollection, class Azure.Maps.Search.SearchInsideGeometryOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.SearchInsideGeometry(System.String,Azure.Core.GeoJson.GeoCollection,Azure.Maps.Search.SearchInsideGeometryOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SearchInsideGeometry (query As String, geometryCollection As GeoCollection, Optional options As SearchInsideGeometryOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of SearchAddressResult)" />
      <MemberSignature Language="F#" Value="abstract member SearchInsideGeometry : string * Azure.Core.GeoJson.GeoCollection * Azure.Maps.Search.SearchInsideGeometryOptions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&#xA;override this.SearchInsideGeometry : string * Azure.Core.GeoJson.GeoCollection * Azure.Maps.Search.SearchInsideGeometryOptions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;" Usage="mapsSearchClient.SearchInsideGeometry (query, geometryCollection, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="geometryCollection" Type="Azure.Core.GeoJson.GeoCollection" />
        <Parameter Name="options" Type="Azure.Maps.Search.SearchInsideGeometryOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="query"> The POI name to search for (e.g., "statue of liberty", "starbucks"), must be properly URL encoded. </param>
        <param name="geometryCollection"> This represents the geometry for one or more geographical features (parks, state boundary etc.) to search in and should be a GeoJSON compliant type. Please refer to <see href="https://tools.ietf.org/html/rfc7946">RFC 7946</see> for details. </param>
        <param name="options"> additional options </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Search inside geometry. The Search Geometry endpoint allows you to perform a free form search inside a single geometry or many of them. The search results that fall inside the geometry/geometries will be returned.&lt;br&gt;&lt;br&gt;To send the geometry you will use a `POST` request where the request body will contain the `geometry` object represented as a `GeoJSON` type and the `Content-Type` header will be set to `application/json`. The geographical features to be searched can be modeled as Polygon and/or Circle geometries represented using any one of the following `GeoJSON` types:&lt;ul&gt;&lt;li&gt;**GeoJSON FeatureCollection** &lt;br&gt;The `geometry` can be represented as a `GeoJSON FeatureCollection` object. This is the recommended option if the geometry contains both Polygons and Circles. The `FeatureCollection` can contain a max of 50 `GeoJSON Feature` objects. Each `Feature` object should represent either a Polygon or a Circle with the following conditions:&lt;ul style="list-style-type:none"&gt;&lt;li&gt;A `Feature` object for the Polygon geometry can have a max of 50 coordinates and it's properties must be empty.&lt;/li&gt;&lt;li&gt;A `Feature` object for the Circle geometry is composed of a _center_ represented using a `GeoJSON Point` type and a _radius_ value (in meters) which must be specified in the object's properties along with the _subType_ property whose value should be 'Circle'.&lt;/li&gt;&lt;/ul&gt;&lt;br&gt; Please see the Examples section below for a sample `FeatureCollection` representation.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;**GeoJSON GeometryCollection**&lt;br&gt;The `geometry` can be represented as a `GeoJSON GeometryCollection` object. This is the recommended option if the geometry contains a list of Polygons only. The `GeometryCollection` can contain a max of 50 `GeoJSON Polygon` objects. Each `Polygon` object can have a max of 50 coordinates. Please see the Examples section below for a sample `GeometryCollection` representation.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;**GeoJSON Polygon**&lt;br&gt;The `geometry` can be represented as a `GeoJSON Polygon` object. This is the recommended option if the geometry contains a single Polygon. The `Polygon` object can have a max of 50 coordinates. Please see the Examples section below for a sample `Polygon` representation.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;.&lt;br&gt;&lt;br&gt;
            </summary>
        <returns>To be added.</returns>
        <remarks>
             **Search Inside Geometry**
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="SearchInsideGeometry">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt; SearchInsideGeometry (string query, Azure.Core.GeoJson.GeoObject geometry, Azure.Maps.Search.SearchInsideGeometryOptions options = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Maps.Search.Models.SearchAddressResult&gt; SearchInsideGeometry(string query, class Azure.Core.GeoJson.GeoObject geometry, class Azure.Maps.Search.SearchInsideGeometryOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.SearchInsideGeometry(System.String,Azure.Core.GeoJson.GeoObject,Azure.Maps.Search.SearchInsideGeometryOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SearchInsideGeometry (query As String, geometry As GeoObject, Optional options As SearchInsideGeometryOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of SearchAddressResult)" />
      <MemberSignature Language="F#" Value="abstract member SearchInsideGeometry : string * Azure.Core.GeoJson.GeoObject * Azure.Maps.Search.SearchInsideGeometryOptions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&#xA;override this.SearchInsideGeometry : string * Azure.Core.GeoJson.GeoObject * Azure.Maps.Search.SearchInsideGeometryOptions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;" Usage="mapsSearchClient.SearchInsideGeometry (query, geometry, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="geometry" Type="Azure.Core.GeoJson.GeoObject" />
        <Parameter Name="options" Type="Azure.Maps.Search.SearchInsideGeometryOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="query"> The POI name to search for (e.g., "statue of liberty", "starbucks"), must be properly URL encoded. </param>
        <param name="geometry"> This represents the geometry for one or more geographical features (parks, state boundary etc.) to search in and should be a GeoJSON compliant type. Please refer to <see href="https://tools.ietf.org/html/rfc7946">RFC 7946</see> for details. </param>
        <param name="options"> additional options </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Search inside geometry. The Search Geometry endpoint allows you to perform a free form search inside a single geometry or many of them. The search results that fall inside the geometry/geometries will be returned.&lt;br&gt;&lt;br&gt;To send the geometry you will use a `POST` request where the request body will contain the `geometry` object represented as a `GeoJSON` type and the `Content-Type` header will be set to `application/json`. The geographical features to be searched can be modeled as Polygon and/or Circle geometries represented using any one of the following `GeoJSON` types:&lt;ul&gt;&lt;li&gt;**GeoJSON FeatureCollection** &lt;br&gt;The `geometry` can be represented as a `GeoJSON FeatureCollection` object. This is the recommended option if the geometry contains both Polygons and Circles. The `FeatureCollection` can contain a max of 50 `GeoJSON Feature` objects. Each `Feature` object should represent either a Polygon or a Circle with the following conditions:&lt;ul style="list-style-type:none"&gt;&lt;li&gt;A `Feature` object for the Polygon geometry can have a max of 50 coordinates and it's properties must be empty.&lt;/li&gt;&lt;li&gt;A `Feature` object for the Circle geometry is composed of a _center_ represented using a `GeoJSON Point` type and a _radius_ value (in meters) which must be specified in the object's properties along with the _subType_ property whose value should be 'Circle'.&lt;/li&gt;&lt;/ul&gt;&lt;br&gt; Please see the Examples section below for a sample `FeatureCollection` representation.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;**GeoJSON GeometryCollection**&lt;br&gt;The `geometry` can be represented as a `GeoJSON GeometryCollection` object. This is the recommended option if the geometry contains a list of Polygons only. The `GeometryCollection` can contain a max of 50 `GeoJSON Polygon` objects. Each `Polygon` object can have a max of 50 coordinates. Please see the Examples section below for a sample `GeometryCollection` representation.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;**GeoJSON Polygon**&lt;br&gt;The `geometry` can be represented as a `GeoJSON Polygon` object. This is the recommended option if the geometry contains a single Polygon. The `Polygon` object can have a max of 50 coordinates. Please see the Examples section below for a sample `Polygon` representation.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;.&lt;br&gt;&lt;br&gt;
            </summary>
        <returns>To be added.</returns>
        <remarks>
             **Search Inside Geometry**
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="SearchInsideGeometryAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt; SearchInsideGeometryAsync (string query, Azure.Core.GeoJson.GeoCollection geometryCollection, Azure.Maps.Search.SearchInsideGeometryOptions options = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Maps.Search.Models.SearchAddressResult&gt;&gt; SearchInsideGeometryAsync(string query, class Azure.Core.GeoJson.GeoCollection geometryCollection, class Azure.Maps.Search.SearchInsideGeometryOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.SearchInsideGeometryAsync(System.String,Azure.Core.GeoJson.GeoCollection,Azure.Maps.Search.SearchInsideGeometryOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SearchInsideGeometryAsync (query As String, geometryCollection As GeoCollection, Optional options As SearchInsideGeometryOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of SearchAddressResult))" />
      <MemberSignature Language="F#" Value="abstract member SearchInsideGeometryAsync : string * Azure.Core.GeoJson.GeoCollection * Azure.Maps.Search.SearchInsideGeometryOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;&#xA;override this.SearchInsideGeometryAsync : string * Azure.Core.GeoJson.GeoCollection * Azure.Maps.Search.SearchInsideGeometryOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;" Usage="mapsSearchClient.SearchInsideGeometryAsync (query, geometryCollection, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="geometryCollection" Type="Azure.Core.GeoJson.GeoCollection" />
        <Parameter Name="options" Type="Azure.Maps.Search.SearchInsideGeometryOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="query"> The POI name to search for (e.g., "statue of liberty", "starbucks"), must be properly URL encoded. </param>
        <param name="geometryCollection"> This represents the geometry for one or more geographical features (parks, state boundary etc.) to search in and should be a GeoJSON compliant type. Please refer to <see href="https://tools.ietf.org/html/rfc7946">RFC 7946</see> for details. </param>
        <param name="options"> additional options </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Search inside geometry. The Search Geometry endpoint allows you to perform a free form search inside a single geometry or many of them. The search results that fall inside the geometry/geometries will be returned.&lt;br&gt;&lt;br&gt;To send the geometry you will use a `POST` request where the request body will contain the `geometry` object represented as a `GeoJSON` type and the `Content-Type` header will be set to `application/json`. The geographical features to be searched can be modeled as Polygon and/or Circle geometries represented using any one of the following `GeoJSON` types:&lt;ul&gt;&lt;li&gt;**GeoJSON FeatureCollection** &lt;br&gt;The `geometry` can be represented as a `GeoJSON FeatureCollection` object. This is the recommended option if the geometry contains both Polygons and Circles. The `FeatureCollection` can contain a max of 50 `GeoJSON Feature` objects. Each `Feature` object should represent either a Polygon or a Circle with the following conditions:&lt;ul style="list-style-type:none"&gt;&lt;li&gt;A `Feature` object for the Polygon geometry can have a max of 50 coordinates and it's properties must be empty.&lt;/li&gt;&lt;li&gt;A `Feature` object for the Circle geometry is composed of a _center_ represented using a `GeoJSON Point` type and a _radius_ value (in meters) which must be specified in the object's properties along with the _subType_ property whose value should be 'Circle'.&lt;/li&gt;&lt;/ul&gt;&lt;br&gt; Please see the Examples section below for a sample `FeatureCollection` representation.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;**GeoJSON GeometryCollection**&lt;br&gt;The `geometry` can be represented as a `GeoJSON GeometryCollection` object. This is the recommended option if the geometry contains a list of Polygons only. The `GeometryCollection` can contain a max of 50 `GeoJSON Polygon` objects. Each `Polygon` object can have a max of 50 coordinates. Please see the Examples section below for a sample `GeometryCollection` representation.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;**GeoJSON Polygon**&lt;br&gt;The `geometry` can be represented as a `GeoJSON Polygon` object. This is the recommended option if the geometry contains a single Polygon. The `Polygon` object can have a max of 50 coordinates. Please see the Examples section below for a sample `Polygon` representation.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;.&lt;br&gt;&lt;br&gt;
            </summary>
        <returns>To be added.</returns>
        <remarks>
             **Search Inside Geometry**
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="SearchInsideGeometryAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt; SearchInsideGeometryAsync (string query, Azure.Core.GeoJson.GeoObject geometry, Azure.Maps.Search.SearchInsideGeometryOptions options = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Maps.Search.Models.SearchAddressResult&gt;&gt; SearchInsideGeometryAsync(string query, class Azure.Core.GeoJson.GeoObject geometry, class Azure.Maps.Search.SearchInsideGeometryOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.SearchInsideGeometryAsync(System.String,Azure.Core.GeoJson.GeoObject,Azure.Maps.Search.SearchInsideGeometryOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SearchInsideGeometryAsync (query As String, geometry As GeoObject, Optional options As SearchInsideGeometryOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of SearchAddressResult))" />
      <MemberSignature Language="F#" Value="abstract member SearchInsideGeometryAsync : string * Azure.Core.GeoJson.GeoObject * Azure.Maps.Search.SearchInsideGeometryOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;&#xA;override this.SearchInsideGeometryAsync : string * Azure.Core.GeoJson.GeoObject * Azure.Maps.Search.SearchInsideGeometryOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;" Usage="mapsSearchClient.SearchInsideGeometryAsync (query, geometry, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="geometry" Type="Azure.Core.GeoJson.GeoObject" />
        <Parameter Name="options" Type="Azure.Maps.Search.SearchInsideGeometryOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="query"> The POI name to search for (e.g., "statue of liberty", "starbucks"), must be properly URL encoded. </param>
        <param name="geometry"> This represents the geometry for one or more geographical features (parks, state boundary etc.) to search in and should be a GeoJSON compliant type. Please refer to <see href="https://tools.ietf.org/html/rfc7946">RFC 7946</see> for details. </param>
        <param name="options"> additional options </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Search inside geometry. The Search Geometry endpoint allows you to perform a free form search inside a single geometry or many of them. The search results that fall inside the geometry/geometries will be returned.&lt;br&gt;&lt;br&gt;To send the geometry you will use a `POST` request where the request body will contain the `geometry` object represented as a `GeoJSON` type and the `Content-Type` header will be set to `application/json`. The geographical features to be searched can be modeled as Polygon and/or Circle geometries represented using any one of the following `GeoJSON` types:&lt;ul&gt;&lt;li&gt;**GeoJSON FeatureCollection** &lt;br&gt;The `geometry` can be represented as a `GeoJSON FeatureCollection` object. This is the recommended option if the geometry contains both Polygons and Circles. The `FeatureCollection` can contain a max of 50 `GeoJSON Feature` objects. Each `Feature` object should represent either a Polygon or a Circle with the following conditions:&lt;ul style="list-style-type:none"&gt;&lt;li&gt;A `Feature` object for the Polygon geometry can have a max of 50 coordinates and it's properties must be empty.&lt;/li&gt;&lt;li&gt;A `Feature` object for the Circle geometry is composed of a _center_ represented using a `GeoJSON Point` type and a _radius_ value (in meters) which must be specified in the object's properties along with the _subType_ property whose value should be 'Circle'.&lt;/li&gt;&lt;/ul&gt;&lt;br&gt; Please see the Examples section below for a sample `FeatureCollection` representation.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;**GeoJSON GeometryCollection**&lt;br&gt;The `geometry` can be represented as a `GeoJSON GeometryCollection` object. This is the recommended option if the geometry contains a list of Polygons only. The `GeometryCollection` can contain a max of 50 `GeoJSON Polygon` objects. Each `Polygon` object can have a max of 50 coordinates. Please see the Examples section below for a sample `GeometryCollection` representation.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;li&gt;**GeoJSON Polygon**&lt;br&gt;The `geometry` can be represented as a `GeoJSON Polygon` object. This is the recommended option if the geometry contains a single Polygon. The `Polygon` object can have a max of 50 coordinates. Please see the Examples section below for a sample `Polygon` representation.&lt;br&gt;&lt;br&gt;&lt;/li&gt;&lt;/ul&gt;.&lt;br&gt;&lt;br&gt;
            </summary>
        <returns>To be added.</returns>
        <remarks>
             **Search Inside Geometry**
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="SearchNearbyPointOfInterest">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt; SearchNearbyPointOfInterest (Azure.Maps.Search.SearchNearbyPointOfInterestOptions options = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Maps.Search.Models.SearchAddressResult&gt; SearchNearbyPointOfInterest(class Azure.Maps.Search.SearchNearbyPointOfInterestOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.SearchNearbyPointOfInterest(Azure.Maps.Search.SearchNearbyPointOfInterestOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SearchNearbyPointOfInterest (Optional options As SearchNearbyPointOfInterestOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of SearchAddressResult)" />
      <MemberSignature Language="F#" Value="abstract member SearchNearbyPointOfInterest : Azure.Maps.Search.SearchNearbyPointOfInterestOptions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&#xA;override this.SearchNearbyPointOfInterest : Azure.Maps.Search.SearchNearbyPointOfInterestOptions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;" Usage="mapsSearchClient.SearchNearbyPointOfInterest (options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="Azure.Maps.Search.SearchNearbyPointOfInterestOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="options"> additional options  </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Nearby search API. If you have a use case for only retrieving POI results around a specific location, the nearby search method may be the right choice. This endpoint will only return POI results, and does not take in a search query parameter.
            </summary>
        <returns>To be added.</returns>
        <remarks>
             **Nearby Search**
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="SearchNearbyPointOfInterestAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt; SearchNearbyPointOfInterestAsync (Azure.Maps.Search.SearchNearbyPointOfInterestOptions options = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Maps.Search.Models.SearchAddressResult&gt;&gt; SearchNearbyPointOfInterestAsync(class Azure.Maps.Search.SearchNearbyPointOfInterestOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.SearchNearbyPointOfInterestAsync(Azure.Maps.Search.SearchNearbyPointOfInterestOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SearchNearbyPointOfInterestAsync (Optional options As SearchNearbyPointOfInterestOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of SearchAddressResult))" />
      <MemberSignature Language="F#" Value="abstract member SearchNearbyPointOfInterestAsync : Azure.Maps.Search.SearchNearbyPointOfInterestOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;&#xA;override this.SearchNearbyPointOfInterestAsync : Azure.Maps.Search.SearchNearbyPointOfInterestOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;" Usage="mapsSearchClient.SearchNearbyPointOfInterestAsync (options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="Azure.Maps.Search.SearchNearbyPointOfInterestOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="options"> additional options  </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Nearby search API. If you have a use case for only retrieving POI results around a specific location, the nearby search method may be the right choice. This endpoint will only return POI results, and does not take in a search query parameter.
            </summary>
        <returns>To be added.</returns>
        <remarks>
             **Nearby Search**
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="SearchPointOfInterest">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt; SearchPointOfInterest (string query, bool? IsTypeAhead = default, Azure.Maps.Search.OperatingHoursRange? OperatingHours = default, Azure.Core.GeoJson.GeoBoundingBox BoundingBox = default, Azure.Maps.Search.SearchPointOfInterestOptions options = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Maps.Search.Models.SearchAddressResult&gt; SearchPointOfInterest(string query, valuetype System.Nullable`1&lt;bool&gt; IsTypeAhead, valuetype System.Nullable`1&lt;valuetype Azure.Maps.Search.OperatingHoursRange&gt; OperatingHours, class Azure.Core.GeoJson.GeoBoundingBox BoundingBox, class Azure.Maps.Search.SearchPointOfInterestOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.SearchPointOfInterest(System.String,System.Nullable{System.Boolean},System.Nullable{Azure.Maps.Search.OperatingHoursRange},Azure.Core.GeoJson.GeoBoundingBox,Azure.Maps.Search.SearchPointOfInterestOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SearchPointOfInterest (query As String, Optional IsTypeAhead As Nullable(Of Boolean) = Nothing, Optional OperatingHours As Nullable(Of OperatingHoursRange) = Nothing, Optional BoundingBox As GeoBoundingBox = Nothing, Optional options As SearchPointOfInterestOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of SearchAddressResult)" />
      <MemberSignature Language="F#" Value="abstract member SearchPointOfInterest : string * Nullable&lt;bool&gt; * Nullable&lt;Azure.Maps.Search.OperatingHoursRange&gt; * Azure.Core.GeoJson.GeoBoundingBox * Azure.Maps.Search.SearchPointOfInterestOptions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&#xA;override this.SearchPointOfInterest : string * Nullable&lt;bool&gt; * Nullable&lt;Azure.Maps.Search.OperatingHoursRange&gt; * Azure.Core.GeoJson.GeoBoundingBox * Azure.Maps.Search.SearchPointOfInterestOptions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;" Usage="mapsSearchClient.SearchPointOfInterest (query, IsTypeAhead, OperatingHours, BoundingBox, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="IsTypeAhead" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="OperatingHours" Type="System.Nullable&lt;Azure.Maps.Search.OperatingHoursRange&gt;" />
        <Parameter Name="BoundingBox" Type="Azure.Core.GeoJson.GeoBoundingBox" />
        <Parameter Name="options" Type="Azure.Maps.Search.SearchPointOfInterestOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="query"> The POI name to search for (e.g., "statue of liberty", "starbucks"), must be properly URL encoded. </param>
        <param name="IsTypeAhead"> Boolean. If the typeahead flag is set, the query will be interpreted as a partial input and the search will enter predictive mode. </param>
        <param name="OperatingHours"> Hours of operation for a POI (Points of Interest). The availability of hours of operation will vary based on the data available. If not passed, then no opening hours information will be returned. </param>
        <param name="BoundingBox"> Bounding Box </param>
        <param name="options"> additional options  </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Points of Interest (POI) Search allows you to request POI results by name. Search supports additional query parameters such as language and filtering results by area of interest driven by country or bounding box.  Endpoint will return only POI results matching the query string. Response includes POI details such as address, a pair of coordinates location and category.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SearchPointOfInterestAlongRoute">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt; SearchPointOfInterestAlongRoute (string query, int maxDetourTime, Azure.Core.GeoJson.GeoLineString route, Azure.Maps.Search.SearchAlongRouteOptions options = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Maps.Search.Models.SearchAddressResult&gt; SearchPointOfInterestAlongRoute(string query, int32 maxDetourTime, class Azure.Core.GeoJson.GeoLineString route, class Azure.Maps.Search.SearchAlongRouteOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.SearchPointOfInterestAlongRoute(System.String,System.Int32,Azure.Core.GeoJson.GeoLineString,Azure.Maps.Search.SearchAlongRouteOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SearchPointOfInterestAlongRoute (query As String, maxDetourTime As Integer, route As GeoLineString, Optional options As SearchAlongRouteOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of SearchAddressResult)" />
      <MemberSignature Language="F#" Value="abstract member SearchPointOfInterestAlongRoute : string * int * Azure.Core.GeoJson.GeoLineString * Azure.Maps.Search.SearchAlongRouteOptions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&#xA;override this.SearchPointOfInterestAlongRoute : string * int * Azure.Core.GeoJson.GeoLineString * Azure.Maps.Search.SearchAlongRouteOptions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;" Usage="mapsSearchClient.SearchPointOfInterestAlongRoute (query, maxDetourTime, route, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="maxDetourTime" Type="System.Int32" />
        <Parameter Name="route" Type="Azure.Core.GeoJson.GeoLineString" />
        <Parameter Name="options" Type="Azure.Maps.Search.SearchAlongRouteOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="query"> The POI name to search for (e.g., "statue of liberty", "starbucks"), must be properly URL encoded. </param>
        <param name="maxDetourTime"> Maximum detour time of the point of interest in seconds. Max value is 3600 seconds. </param>
        <param name="route"> This represents the route to search along and should be a valid `GeoJSON LineString` type. Please refer to <see href="https://tools.ietf.org/html/rfc7946#section-3.1.4">RFC 7946</see> for details. </param>
        <param name="options"> additional options </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            The Search Along Route endpoint allows you to perform a fuzzy search for POIs along a specified route. This search is constrained by specifying the `maxDetourTime` limiting measure.&lt;br&gt;&lt;br&gt;To send the route-points you will use a `POST` request where the request body will contain the `route` object represented as a `GeoJSON LineString` type and the `Content-Type` header will be set to `application/json`. Each route-point in `route` is represented as a `GeoJSON Position` type i.e. an array where the _longitude_ value is followed by the _latitude_ value and the _altitude_ value is ignored. The `route` should contain at least 2 route-points.&lt;br&gt;&lt;br&gt;It is possible that original route will be altered, some of it's points may be skipped. If the route that passes through the found point is faster than the original one, the `detourTime` value in the response is negative.
            </summary>
        <returns>To be added.</returns>
        <remarks>
             **Search Point Of Interest Along Route**
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="SearchPointOfInterestAlongRouteAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt; SearchPointOfInterestAlongRouteAsync (string query, int maxDetourTime, Azure.Core.GeoJson.GeoLineString route, Azure.Maps.Search.SearchAlongRouteOptions options = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Maps.Search.Models.SearchAddressResult&gt;&gt; SearchPointOfInterestAlongRouteAsync(string query, int32 maxDetourTime, class Azure.Core.GeoJson.GeoLineString route, class Azure.Maps.Search.SearchAlongRouteOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.SearchPointOfInterestAlongRouteAsync(System.String,System.Int32,Azure.Core.GeoJson.GeoLineString,Azure.Maps.Search.SearchAlongRouteOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SearchPointOfInterestAlongRouteAsync (query As String, maxDetourTime As Integer, route As GeoLineString, Optional options As SearchAlongRouteOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of SearchAddressResult))" />
      <MemberSignature Language="F#" Value="abstract member SearchPointOfInterestAlongRouteAsync : string * int * Azure.Core.GeoJson.GeoLineString * Azure.Maps.Search.SearchAlongRouteOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;&#xA;override this.SearchPointOfInterestAlongRouteAsync : string * int * Azure.Core.GeoJson.GeoLineString * Azure.Maps.Search.SearchAlongRouteOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;" Usage="mapsSearchClient.SearchPointOfInterestAlongRouteAsync (query, maxDetourTime, route, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="maxDetourTime" Type="System.Int32" />
        <Parameter Name="route" Type="Azure.Core.GeoJson.GeoLineString" />
        <Parameter Name="options" Type="Azure.Maps.Search.SearchAlongRouteOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="query"> The POI name to search for (e.g., "statue of liberty", "starbucks"), must be properly URL encoded. </param>
        <param name="maxDetourTime"> Maximum detour time of the point of interest in seconds. Max value is 3600 seconds. </param>
        <param name="route"> This represents the route to search along and should be a valid `GeoJSON LineString` type. Please refer to <see href="https://tools.ietf.org/html/rfc7946#section-3.1.4">RFC 7946</see> for details. </param>
        <param name="options"> additional options </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            The Search Along Route endpoint allows you to perform a fuzzy search for POIs along a specified route. This search is constrained by specifying the `maxDetourTime` limiting measure.&lt;br&gt;&lt;br&gt;To send the route-points you will use a `POST` request where the request body will contain the `route` object represented as a `GeoJSON LineString` type and the `Content-Type` header will be set to `application/json`. Each route-point in `route` is represented as a `GeoJSON Position` type i.e. an array where the _longitude_ value is followed by the _latitude_ value and the _altitude_ value is ignored. The `route` should contain at least 2 route-points.&lt;br&gt;&lt;br&gt;It is possible that original route will be altered, some of it's points may be skipped. If the route that passes through the found point is faster than the original one, the `detourTime` value in the response is negative.
            </summary>
        <returns>To be added.</returns>
        <remarks>
             **Search Point Of Interest Along Route**
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="SearchPointOfInterestAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt; SearchPointOfInterestAsync (string query, bool? IsTypeAhead = default, Azure.Maps.Search.OperatingHoursRange? OperatingHours = default, Azure.Core.GeoJson.GeoBoundingBox BoundingBox = default, Azure.Maps.Search.SearchPointOfInterestOptions options = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Maps.Search.Models.SearchAddressResult&gt;&gt; SearchPointOfInterestAsync(string query, valuetype System.Nullable`1&lt;bool&gt; IsTypeAhead, valuetype System.Nullable`1&lt;valuetype Azure.Maps.Search.OperatingHoursRange&gt; OperatingHours, class Azure.Core.GeoJson.GeoBoundingBox BoundingBox, class Azure.Maps.Search.SearchPointOfInterestOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.SearchPointOfInterestAsync(System.String,System.Nullable{System.Boolean},System.Nullable{Azure.Maps.Search.OperatingHoursRange},Azure.Core.GeoJson.GeoBoundingBox,Azure.Maps.Search.SearchPointOfInterestOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SearchPointOfInterestAsync (query As String, Optional IsTypeAhead As Nullable(Of Boolean) = Nothing, Optional OperatingHours As Nullable(Of OperatingHoursRange) = Nothing, Optional BoundingBox As GeoBoundingBox = Nothing, Optional options As SearchPointOfInterestOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of SearchAddressResult))" />
      <MemberSignature Language="F#" Value="abstract member SearchPointOfInterestAsync : string * Nullable&lt;bool&gt; * Nullable&lt;Azure.Maps.Search.OperatingHoursRange&gt; * Azure.Core.GeoJson.GeoBoundingBox * Azure.Maps.Search.SearchPointOfInterestOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;&#xA;override this.SearchPointOfInterestAsync : string * Nullable&lt;bool&gt; * Nullable&lt;Azure.Maps.Search.OperatingHoursRange&gt; * Azure.Core.GeoJson.GeoBoundingBox * Azure.Maps.Search.SearchPointOfInterestOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;" Usage="mapsSearchClient.SearchPointOfInterestAsync (query, IsTypeAhead, OperatingHours, BoundingBox, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="query" Type="System.String" />
        <Parameter Name="IsTypeAhead" Type="System.Nullable&lt;System.Boolean&gt;" />
        <Parameter Name="OperatingHours" Type="System.Nullable&lt;Azure.Maps.Search.OperatingHoursRange&gt;" />
        <Parameter Name="BoundingBox" Type="Azure.Core.GeoJson.GeoBoundingBox" />
        <Parameter Name="options" Type="Azure.Maps.Search.SearchPointOfInterestOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="query"> The POI name to search for (e.g., "statue of liberty", "starbucks"), must be properly URL encoded. </param>
        <param name="IsTypeAhead"> Boolean. If the typeahead flag is set, the query will be interpreted as a partial input and the search will enter predictive mode. </param>
        <param name="OperatingHours"> Hours of operation for a POI (Points of Interest). The availability of hours of operation will vary based on the data available. If not passed, then no opening hours information will be returned. </param>
        <param name="BoundingBox"> Bounding Box </param>
        <param name="options"> additional options  </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Points of Interest (POI) Search allows you to request POI results by name. Search supports additional query parameters such as language and filtering results by area of interest driven by country or bounding box.  Endpoint will return only POI results matching the query string. Response includes POI details such as address, a pair of coordinates location and category.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SearchPointOfInterestCategory">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt; SearchPointOfInterestCategory (Azure.Maps.Search.SearchPointOfInterestCategoryOptions options = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Maps.Search.Models.SearchAddressResult&gt; SearchPointOfInterestCategory(class Azure.Maps.Search.SearchPointOfInterestCategoryOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.SearchPointOfInterestCategory(Azure.Maps.Search.SearchPointOfInterestCategoryOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SearchPointOfInterestCategory (Optional options As SearchPointOfInterestCategoryOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of SearchAddressResult)" />
      <MemberSignature Language="F#" Value="abstract member SearchPointOfInterestCategory : Azure.Maps.Search.SearchPointOfInterestCategoryOptions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&#xA;override this.SearchPointOfInterestCategory : Azure.Maps.Search.SearchPointOfInterestCategoryOptions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;" Usage="mapsSearchClient.SearchPointOfInterestCategory (options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="Azure.Maps.Search.SearchPointOfInterestCategoryOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="options"> additional options  </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Get POI by Category API. Points of Interest (POI) Category Search allows you to request POI results from given category. Search allows to query POIs from one category at a time. Endpoint will only return POI results which are categorized as specified.  Response includes POI details such as address, a pair of coordinates location and classification.
            </summary>
        <returns>To be added.</returns>
        <remarks>
             **Get POI by Category**
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="SearchPointOfInterestCategoryAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt; SearchPointOfInterestCategoryAsync (Azure.Maps.Search.SearchPointOfInterestCategoryOptions options = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Maps.Search.Models.SearchAddressResult&gt;&gt; SearchPointOfInterestCategoryAsync(class Azure.Maps.Search.SearchPointOfInterestCategoryOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.SearchPointOfInterestCategoryAsync(Azure.Maps.Search.SearchPointOfInterestCategoryOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SearchPointOfInterestCategoryAsync (Optional options As SearchPointOfInterestCategoryOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of SearchAddressResult))" />
      <MemberSignature Language="F#" Value="abstract member SearchPointOfInterestCategoryAsync : Azure.Maps.Search.SearchPointOfInterestCategoryOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;&#xA;override this.SearchPointOfInterestCategoryAsync : Azure.Maps.Search.SearchPointOfInterestCategoryOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;" Usage="mapsSearchClient.SearchPointOfInterestCategoryAsync (options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="Azure.Maps.Search.SearchPointOfInterestCategoryOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="options"> additional options  </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Get POI by Category API. Points of Interest (POI) Category Search allows you to request POI results from given category. Search allows to query POIs from one category at a time. Endpoint will only return POI results which are categorized as specified.  Response includes POI details such as address, a pair of coordinates location and classification.
            </summary>
        <returns>To be added.</returns>
        <remarks>
             **Get POI by Category**
             </remarks>
      </Docs>
    </Member>
    <Member MemberName="SearchStructuredAddress">
      <MemberSignature Language="C#" Value="public virtual Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt; SearchStructuredAddress (Azure.Maps.Search.StructuredAddress address, Azure.Maps.Search.Models.SearchStructuredAddressOptions options = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Azure.Response`1&lt;class Azure.Maps.Search.Models.SearchAddressResult&gt; SearchStructuredAddress(class Azure.Maps.Search.StructuredAddress address, class Azure.Maps.Search.Models.SearchStructuredAddressOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.SearchStructuredAddress(Azure.Maps.Search.StructuredAddress,Azure.Maps.Search.Models.SearchStructuredAddressOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SearchStructuredAddress (address As StructuredAddress, Optional options As SearchStructuredAddressOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Response(Of SearchAddressResult)" />
      <MemberSignature Language="F#" Value="abstract member SearchStructuredAddress : Azure.Maps.Search.StructuredAddress * Azure.Maps.Search.Models.SearchStructuredAddressOptions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&#xA;override this.SearchStructuredAddress : Azure.Maps.Search.StructuredAddress * Azure.Maps.Search.Models.SearchStructuredAddressOptions * System.Threading.CancellationToken -&gt; Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;" Usage="mapsSearchClient.SearchStructuredAddress (address, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="Azure.Maps.Search.StructuredAddress" />
        <Parameter Name="options" Type="Azure.Maps.Search.Models.SearchStructuredAddressOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="address"> structured address </param>
        <param name="options"> additional options </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Structured address geocoding. The geocoding search index will be queried for everything above the street level data. No POIs will be returned. Note that the geocoder is very tolerant of typos and incomplete  addresses. It will also handle everything from exact  street addresses or street or intersections as well as higher level geographies such as city centers,  counties, states etc.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SearchStructuredAddressAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt; SearchStructuredAddressAsync (Azure.Maps.Search.StructuredAddress address, Azure.Maps.Search.Models.SearchStructuredAddressOptions options = default, System.Threading.CancellationToken cancellationToken = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;class Azure.Response`1&lt;class Azure.Maps.Search.Models.SearchAddressResult&gt;&gt; SearchStructuredAddressAsync(class Azure.Maps.Search.StructuredAddress address, class Azure.Maps.Search.Models.SearchStructuredAddressOptions options, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:Azure.Maps.Search.MapsSearchClient.SearchStructuredAddressAsync(Azure.Maps.Search.StructuredAddress,Azure.Maps.Search.Models.SearchStructuredAddressOptions,System.Threading.CancellationToken)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function SearchStructuredAddressAsync (address As StructuredAddress, Optional options As SearchStructuredAddressOptions = Nothing, Optional cancellationToken As CancellationToken = Nothing) As Task(Of Response(Of SearchAddressResult))" />
      <MemberSignature Language="F#" Value="abstract member SearchStructuredAddressAsync : Azure.Maps.Search.StructuredAddress * Azure.Maps.Search.Models.SearchStructuredAddressOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;&#xA;override this.SearchStructuredAddressAsync : Azure.Maps.Search.StructuredAddress * Azure.Maps.Search.Models.SearchStructuredAddressOptions * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;" Usage="mapsSearchClient.SearchStructuredAddressAsync (address, options, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Azure.Maps.Search</AssemblyName>
        <AssemblyVersion>1.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;Azure.Response&lt;Azure.Maps.Search.Models.SearchAddressResult&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="Azure.Maps.Search.StructuredAddress" />
        <Parameter Name="options" Type="Azure.Maps.Search.Models.SearchStructuredAddressOptions" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="address"> structured address </param>
        <param name="options"> additional options </param>
        <param name="cancellationToken"> The cancellation token to use. </param>
        <summary>
            Structured address geocoding. The geocoding search index will be queried for everything above the street level data. No POIs will be returned. Note that the geocoder is very tolerant of typos and incomplete  addresses. It will also handle everything from exact  street addresses or street or intersections as well as higher level geographies such as city centers,  counties, states etc.
            </summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
